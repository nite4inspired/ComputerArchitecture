Great! I'll create a 3-month full-time learning schedule based on the course content from the provided site. The schedule will include all labs, assignments, readings, and lectures, structured in a well-organized document. I'll let you know when it's ready for your review.

# Full-Time 3-Month Learning Schedule: CSCI E-95 (Compiler Design & Implementation)

**Course Overview:** This 12-week schedule is based on Harvard Extension School’s **CSCI E-95: Compiler Design and Implementation (Spring 2025)** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#:~:text=Compiler%20Design%20and%20Implementation%20)). It is structured for full-time learning, covering all lectures, readings, programming labs/assignments, and milestones from the course content. Each week outlines the **goal** (focus of learning) and the **milestone** to achieve, along with detailed topics, required readings, and assignments. The primary textbook referenced is _Compilers: Principles, Techniques, and Tools_ by Aho, Lam, Sethi, Ullman (2nd ed.), and additional course materials as noted. The schedule assumes ~40 hours of effort per week, allowing you to thoroughly cover the material and complete all projects in three months.

## Week 1: Course Introduction & C Language Refresher

**Goal:** Understand the course structure and refresh fundamental C programming knowledge. Set up your development environment (Git repository, compiler tools) and familiarize yourself with course policies and tools ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=27%20Classes%20begin%20,of%20the%20C%20Programming%20Language)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,3)).  
**Milestone:** By the end of Week 1, you will have configured all necessary software, completed the course questionnaire, and finished **Problem Set 0**, demonstrating basic C skills and Git usage ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=February%202025%20Description%202%20at,Pass%20Compiler)).

- **Topics Covered:** Introduction to the compiler course (objectives, outline, grading) and an overview of compilers ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=28%20at%208%3A00%20PM%20ET,of%20the%20C%20Programming%20Language)). Review of the C programming language (syntax and semantics) to ensure readiness for compiler coding ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=28%20at%208%3A00%20PM%20ET,of%20the%20C%20Programming%20Language)).
- **Readings:** Skim the course **Overview** and **Learning Objectives** (if provided on the course website) to grasp the big picture. No specific textbook chapters are assigned this week, but it’s recommended to review C language references (e.g., Harbison & Steele _C: A Reference Manual_, Chapter 2) for a refresher on C basics, as this will be needed going forward ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,3)).
- **Lab/Assignment:** **Problem Set 0** – _“Course Questionnaire & Fix-the-Code Exercises”_ ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=2%20at%20Midnight%20Problem%20Set,due)). This introductory lab involves using Git to clone the course repository and submit your answers (tagged as `problem-set-0`) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=The%20Course%20Questionnaire%20and%20Problem,Sets)). It includes a short questionnaire about your background and two small C programs to fix and analyze (“fix-this-program” and a word count program) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=February%202025%20Description%202%20at,Pass%20Compiler)). _Complete and submit Problem Set 0 by the end of this week._

## Week 2: Compiler Basics & Lexical Analysis (Lexer)

**Goal:** Grasp the overall compilation process and begin the first phase of a compiler – lexical analysis. This week you’ll learn how a simple one-pass compiler is structured and how to write a lexer using Lex/Flex ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,of%20the%20C%20Programming%20Language)).  
**Milestone:** By Week 2’s end, you will have implemented a basic lexical analyzer. **Problem Set 1 (Lexer)** will be completed and submitted, capable of tokenizing input according to a simple language specification ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,Midnight%20Problem%20Set%201%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)).

- **Topics Covered:** **Introduction to Compiling** – understanding the phases of a compiler and a simple one-pass compiler structure ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,of%20the%20C%20Programming%20Language)). **Regular Expressions and Lexical Analysis:** how to describe tokens using regex and the role of a lexer. Introduction to **Lex/Flex** tool – writing lexical specification (.lex) and integrating with C code ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,of%20the%20C%20Programming%20Language)). Continued C review as needed for writing the lexer.
- **Readings:** **Harbison/Steele Chapter 2** (C basics) and **Aho et al. Chapters 1–3** – These chapters provide an introduction to compilers and lexical analysis ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,3)). Chapter 1 of Aho et al. covers compiler basics, Chapter 2 introduces a simple one-pass compiler, and Chapter 3 dives into lexical analysis and regular expressions. Complete these readings to understand the theory behind the lexer you are building.
- **Lab/Assignment:** **Problem Set 1 – Lexer** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)). Design and implement a lexical analyzer for a subset of C (or the course’s custom language). You’ll write Lex/Flex rules to recognize tokens (identifiers, keywords, numbers, symbols) and test it with sample input. Begin by studying the provided example `lexer-standalone.lex` and `lexer.c` code from class ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,of%20the%20C%20Programming%20Language)). By mid-week, start coding your own lexer. _Submit Problem Set 1 (via Git) by the end of Week 2_ ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Second%20class%20meeting,Midnight%20Problem%20Set%201%20due)).

## Week 3: Syntax Analysis I – Grammars & Parsing (Parser)

**Goal:** Learn how the compiler’s parser works by studying context-free grammars and top-down parsing. This week introduces syntax analysis fundamentals and parser generator tools (Yacc/Bison) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Third%20class%20meeting,Types%20in%20the%20C%20Programming)).  
**Milestone:** By the end of Week 3, you will have started constructing a parser for the language. **Problem Set 2 (Parser)** is underway, focusing on defining a grammar and building a Yacc/Bison parser ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Third%20class%20meeting,convert%20an%20NFA%20into%20a)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)).

- **Topics Covered:** **Context-Free Grammars (CFGs):** understanding grammars, parse trees, and ambiguity in language syntax ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Third%20class%20meeting,convert%20an%20NFA%20into%20a)). Techniques to refactor grammars (eliminating left recursion and left factoring) for parser compatibility ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Third%20class%20meeting,convert%20an%20NFA%20into%20a)). **Parser Generators (Yacc/Bison):** introduction to Yacc, writing grammar rules in a `.y` file, and integrating with the lexer. In class, the sample lexer (`lexer.lex`) and parser (`parser.y`) for a C subset are reviewed ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Third%20class%20meeting,convert%20an%20NFA%20into%20a)).
- **Readings:** **Aho et al. Chapter 4** – Focus on top-down parsing methods and the theory of syntax analysis ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=grammars,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%204)). This chapter covers constructing predictive parsers and using parser generators, which directly applies to building your Yacc-based parser. Make sure you understand how Yacc works (the course may provide a **“Using YACC/Bison”** guide as well).
- **Lab/Assignment:** **Problem Set 2 – Parser** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)). Define the grammar for the compiler’s language and implement a parser (using Yacc/Bison). Your parser should work with the lexer from PSet1 to recognize syntactically correct programs and build a parse tree. Start by writing grammar productions (perhaps for expressions, statements, etc.) and resolving any conflicts or ambiguities. _Aim to complete the bulk of the parser implementation this week._ (The final submission of PSet 2 is due early next week ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Midnight%20Problem%20Set%202%20due)), so finish by the beginning of Week 4.)

## Week 4: Syntax Analysis II & Lexical Theory (NFA/DFA)

**Goal:** Deepen your understanding of both lexical and syntax analysis. This week you will finish the parser and study lexical analysis theory (formal automata) as well as introduce the compiler’s symbol table module ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Generation%20of%20Symbol%20Tables)).  
**Milestone:** By Week 4’s conclusion, you will have a working parser. **Problem Set 2 (Parser)** will be submitted, and you will begin **Problem Set 3 (Symbol Table Management)**, setting the stage for semantic analysis ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Midnight%20Problem%20Set%202%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=NFA%20and%20DFA,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%205)).

- **Topics Covered:** **Lexical Analysis Theory:** learn about finite automata underpinning lexers. Understand how to convert a regular expression into an NFA, then to a DFA (subset construction) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Generation%20of%20Symbol%20Tables)). This theoretical foundation explains how Lex/Flex generates efficient tokenizers. **Top-Down Parsing & Recursive Descent:** wrap up any remaining parsing concepts (e.g., recursive descent parsing demonstration with `recursiveDescentParser.c`) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Generation%20of%20Symbol%20Tables)). **Symbol Table Introduction:** discuss the role of a symbol table in a compiler (storing identifiers, scopes, types) as a prelude to semantic analysis. In class, Problem Set 3 is introduced, focusing on implementing a symbol table manager ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=NFA%20and%20DFA,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%205)).
- **Readings:** **Aho et al. Chapter 5** – This chapter covers **Syntax Analysis** in depth, including bottom-up parsing theory and an introduction to syntax-directed translation (which connects parsing to semantic actions) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=DFA.%20Complete%20Syntax%20Analysis.%20Top,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%205)). Pay attention to sections on constructing NFAs/DFAs and on symbol tables if covered. Also review any provided course notes on NFAs/DFAs (e.g., _“Example of Regex, NFA, DFA”_ PDF) for practical insight ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,Type%20Checking%20in%20PDF)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,109)).
- **Lab/Assignment:** **Complete Problem Set 2 – Parser:** Finalize and test your parser, ensuring it correctly parses valid programs and rejects invalid syntax. Submit PSet 2 by its deadline (around the start of this week) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=18%20Fourth%20class%20meeting,Midnight%20Problem%20Set%202%20due)).  
    **Problem Set 3 – Symbol Table Management** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)): Begin designing a symbol table module for the compiler. This involves choosing data structures for scopes and symbol entries, handling declarations, and lookups. The assignment likely requires building a symbol table that integrates with your parser (e.g., actions in Yacc to insert symbols). Start implementing this, focusing on global and local scope handling. _You will continue this assignment into next week._

## Week 5: Semantic Analysis – Parse Trees, ASTs & Type Systems

**Goal:** Learn how the compiler represents and checks program structure semantically. This week covers constructing abstract syntax trees (ASTs) and performing type checking, using the symbol table to manage scope and types ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=25%20Fifth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)).  
**Milestone:** By the end of Week 5, your compiler will generate parse trees/ASTs and have the groundwork for type checking. You should be close to finishing **Problem Set 3 (Symbol Table)** and be prepared to start the type checking assignment next week ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=25%20Fifth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)).

- **Topics Covered:** **Parse Trees and ASTs:** understanding how to transform concrete parse trees into abstract syntax trees for easier semantic processing ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=25%20Fifth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). The class discusses building AST nodes for expressions, statements, etc., and likely introduces a **Type Tree** to represent type information of expressions. **Symbol Tables and Scope:** how the symbol table is populated during parsing (e.g., on variable declarations) and used for semantic checks (like undeclared variable errors). **FIRST/FOLLOW and LL(1) Parsing:** brief coverage of predictive parsing tables and LL(1) grammar properties ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=25%20Fifth%20class%20meeting,Point%20Number%20Representations.%20For)) (to solidify understanding of parser construction). **Basic Type Checking:** introduction to data type representations (e.g., how C types are represented, size and alignment) and numeric representations (integers vs floating point) in a compiler ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=25%20Fifth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). This sets up the need for a type checking module.
- **Readings:** **Aho et al. Chapter 6** – Focus on **Syntax-Directed Translation** and **Type Checking** basics ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=%28Incl,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). Chapter 6 in the textbook covers syntax-directed definitions and how to perform semantic actions like building ASTs and doing type checking as you parse. It also discusses type systems and type expressions. Additionally, review the course’s slides on **Symbol Table Management** and **Type Checking** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,Reduce%20Parsing%20in%20PDF)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,Intermediate%20Representation%20in%20PDF)) for applied perspective.
- **Lab/Assignment:** **Continue/Complete Problem Set 3 – Symbol Table Management** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,119)). Ensure your symbol table supports nested scopes (for example, entering a new scope on function definitions or blocks and exiting on scope end) and can store information like variable type, scope level, etc. Test it with some declarations and references in your parser. Plan to wrap up PSet 3 by this week’s end or early next week (it’s originally due around this time) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=Aho%2FLam%2FSethi%2FUllman%20chapter%206,Eighth%20class%20meeting)).  
    _Anticipated next assignment:_ **Problem Set 4 – Type Checker** will be introduced (if not already). You might receive starter code or a description this week. If so, begin thinking about how to use the AST and symbol table to implement semantic checks (type compatibility, conversions, function signatures, etc.). Actual coding of PSet 4 will start once PSet 3 is submitted (which will be in Week 6).

## Week 6: Advanced Parsing, Type Checking & Introduction to MIPS

**Goal:** Finalize the compiler’s front-end by implementing type checking, and bridge into the back-end with an intro to code generation. You will learn about bottom-up parsing (shift-reduce) and get familiar with the target machine architecture (MIPS) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)).  
**Milestone:** By Week 6’s end, you will have completed **Problem Set 3** and made significant progress on **Problem Set 4 (Type Checker)** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=Load%2FStore%2C%20Jump%20and%20Branch,23)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Type%20checker)). Additionally, you will have a basic understanding of the MIPS architecture, which will be used for code generation in later assignments.

- **Topics Covered:** **Type Checking:** continue and complete coverage of static type checking. Discussion includes the IEEE 754 floating-point representation and handling conversions in C (standard promotions and casts) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)). By now, you should understand how to enforce type rules (e.g., cannot assign int to char without cast, etc.) in your compiler. **Bottom-Up Parsing (Shift-Reduce):** an overview of bottom-up parsing techniques (LR parsing). The class likely demonstrates shift-reduce parsing with examples and how a parse stack works ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)). (While you may not implement an LR parser manually, this concept is useful for understanding parser generators more deeply.) **MIPS Architecture Intro:** learn about the MIPS CPU architecture as a typical target for code generation ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)). Topics include MIPS registers, instruction formats (I-type, J-type, R-type), and basic instruction categories (arithmetic, load/store, jumps, branches) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)). This is crucial background for writing a code generator in upcoming weeks.
- **Readings:** **(Review) Aho et al. Chapter 6** – Re-read relevant sections on **Type Systems and Type Conversions** to support your type checker implementation ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=Instruction%20Set%20Presentation%3A%20Arithmetic%20R,23)). Ensure you understand examples of type enforcement and conversion in the compiler. For MIPS, read the provided course notes or appendix on the **MIPS Instruction Set** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,Present)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,Register%20Allocation%20in%20PDF)) (the class might supply a PDF titled “MIPS Instruction Set”). No new Dragon Book chapter this week (Chapter 6 was already assigned), so focus on fully digesting type checking and the supplied MIPS documentation.
- **Lab/Assignment:** **Submit Problem Set 3 (Symbol Table)** at the beginning of this week (if not done in Week 5).  
    **Problem Set 4 – Type Checker** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Intermediate%20code%20generator)): Implement semantic analysis in your compiler. Using the AST and symbol table, traverse the AST to check for type errors (type mismatches in assignments or operations, undeclared identifiers, incompatible function arguments, etc.). Also implement type coercions where appropriate (e.g., widening primitives) and produce meaningful error messages. Begin coding and testing your type checking routines this week. You should also incorporate the handling of standard conversions (integral promotions, etc.) as discussed in class ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=4%20Sixth%20class%20meeting,Time%20Environments)). _Plan to complete PSet 4 by the middle of next week (Week 7/8), as the midterm is approaching_ ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=9%20at%20Midnight%20Problem%20Set,Midnight%20Problem%20Set%204%20due)).

## Week 7: Syntax-Directed Translation & Run-Time Environments

**Goal:** Transition from the front-end to the middle/back-end of the compiler. This week covers syntax-directed translation techniques and the design of run-time environments, which lays the groundwork for generating intermediate code and managing program execution at runtime ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Seventh%20class%20meeting.%20Syntax,Midnight%20Problem%20Set%204%20due)).  
**Milestone:** By the end of Week 7, you will have a working **type checker** (PSet 4 nearly or fully done) and an understanding of how the compiler will handle runtime storage. You should be ready to take the midterm exam on the first half of the course next week ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Seventh%20class%20meeting.%20Syntax,Midnight%20Problem%20Set%204%20due)).

- **Topics Covered:** **Syntax-Directed Translation (SDT):** learn how to attach semantic actions to grammar rules. This concept shows how the compiler can construct intermediate representations (like IR code or AST modifications) during parsing ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=%2A%20Syntax,Construction%20Time)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=%2A%20Analysis%20of%20Syntax,An%20algorithm%20for%20Unification)). The class might discuss examples of evaluating expressions or building output code on the fly using SDTs. **Run-Time Environments:** understand how programs manage memory at runtime ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=%2A%20Run,Dynamic%20Storage%20Allocation%20Techniques)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Backpatching)). Topics include the layout of memory segments (code, static data, heap, stack), activation records (stack frames) for function calls, managing the call stack for nested procedures, and heap allocation strategies ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Seventh%20class%20meeting.%20Syntax,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%207)). These concepts are crucial for generating correct code (especially function call/return sequences and handling variables’ lifetimes).
- **Readings:** **Aho et al. Chapter 7** – This chapter focuses on **Run-Time Environments** and syntax-directed translation ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=11%20Seventh%20class%20meeting.%20Syntax,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%207)). Study how different programming language features (scopes, recursion, dynamic allocation) are handled at runtime. Pay attention to parameter passing mechanisms and stack frame structure, as these will inform your code generation later. If available, review course slides on **Run-Time Environment** and **Syntax-Directed Translation** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=%2A%20Example%20of%20Shift,Optimization%20in%20PDF)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,103)) for concrete examples.
- **Lab/Assignment:** **Continue/Complete Problem Set 4 – Type Checker** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Intermediate%20code%20generator)). By now, your type checking module should be nearly finished. Test it thoroughly on various small programs (try some that have deliberate type errors to ensure your compiler catches them). _Submit PSet 4 by the end of this week or before the midterm._  
    _No new programming assignment is introduced this week_, allowing you to focus on reviewing for the midterm exam. However, you might start thinking ahead about the upcoming **Problem Set 5 (Intermediate Code Generation)** which will begin right after the midterm. Ensure you understand the concept of three-address code and have your parser/AST in good shape, as you’ll generate IR from it.

## Week 8: **Midterm Exam** and Course Review

**Goal:** Demonstrate your knowledge of the course material covered so far (lexical analysis through run-time environments) and solidify any areas of weakness. Use this shorter week to review and prepare for the transition to code generation in the second half of the course.  
**Milestone:** By the end of Week 8, you will have taken the **Midterm Exam** (covering Weeks 1–7 content) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=17,Midnight%20Problem%20Set%204%20due)) and formally completed **Problem Set 4 (Type Checker)** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=9%20at%20Midnight%20Problem%20Set,Midnight%20Problem%20Set%204%20due)). You should be confident in the compiler front-end material moving forward.

- **Topics Covered:** **Midterm Examination:** The midterm is typically a written exam testing theoretical and practical understanding of the first half of the course. Expect questions on lexical vs. syntax analysis (regex, NFAs/DFAs, CFGs, parsing techniques), semantic analysis (symbol tables, type checking), and compiler fundamentals. No new lecture topics are introduced this week, aside from possibly a review session. If any time remains after the exam, the instructor might give a brief overview of upcoming topics or answer questions.
- **Readings:** No new readings. **Review Chapters 1–7** of Aho et al., class notes, and your assignments to prepare for the exam. Focus on key concepts: how a lexer/tokenizer works, how a parser is constructed (LL vs LR), how the symbol table and type checker ensure semantic correctness, etc. Revisit tricky parts like grammar transformations or runtime stack layout.
- **Lab/Assignment:** **Midterm Exam:** Schedule and take the exam under simulated conditions (closed-book, timed, as per course rules). After completing it, spend time grading it yourself with provided solutions if available, to identify any gaps in understanding.  
    **Finalize Problem Set 4:** If you haven’t submitted the type checker yet, do so now (it was due around this time) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=17,Midnight%20Problem%20Set%204%20due)). Ensure your repository is up to date with all changes.  
    _After the exam,_ you can start getting ready for the next project. The second half will kick off with intermediate code generation. Set up your environment for the next phase (for example, ensure you have a MIPS simulator or the SPIM environment ready, as it may be needed for testing generated code).

## Week 9: Intermediate Code Generation (Three-Address Code)

**Goal:** Begin the compiler back-end by generating an intermediate representation (IR) of the code. You will learn about three-address code (quadruples) and how to produce IR from the AST, which is the first step in translating to machine code ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=1%20Ninth%20class%20meeting,MIPS%20Architecture%20and%20Instruction%20Set)).  
**Milestone:** By the end of Week 9, you will have designed the intermediate code structures for your compiler and started generating IR for simple program constructs. **Problem Set 5 (Intermediate Code Generator)** will be in progress, focusing on translating parsed code into IR form ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)).

- **Topics Covered:** **Intermediate Representation (IR):** understanding three-address code (TAC) – instructions with at most three operands (e.g., `x = y + z`). The class discusses how to represent high-level language constructs in IR, such as arithmetic expressions, assignments, conditional jumps, and function calls ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=1%20Ninth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). **Examples of IR Generation:** step-by-step translation of parse subtrees into sequences of TAC (for instance, an `if-else` statement into labels and jumps, or a `while` loop into a control-flow loop with labels) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=1%20Ninth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). Key concepts include **quadruples** (operator, arg1, arg2, result) and **l-values vs. r-values** in the context of code generation (ensuring you handle things like pointer dereferences correctly as l-values) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=accessing%20user%20variables%20for%20load,Instruction%20Set%20Presentation%3A%20Arithmetic)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=dereferencing%2C%20casting%29,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%208)). Also introduced is the idea of **Single Static Assignment (SSA)** form in IR, though you may not implement SSA, understanding it helps in thinking about optimizations.
- **Readings:** _The course schedule suggests revisiting Chapter 6,_ which may cover some IR material (possibly a section on translation to intermediate code) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=creation%20of%20IR%20nodes,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%206)). However, to get a full picture, also read **Aho et al. Chapter 8 (first part)** which deals with intermediate code generation and runtime considerations. Check if the course provided a specific **Intermediate Representation** handout or slides ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=%2A%20Example%20of%20Shift,Optimization%20in%20PDF)) – for example, a PDF titled “Intermediate Representation” likely summarizes how to generate IR for different constructs. Study those materials to guide your implementation.
- **Lab/Assignment:** **Problem Set 5 – Intermediate Code Generator** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). Extend your compiler to produce intermediate code (instead of or in addition to an AST). You’ll write code to traverse the AST or integrate actions in your parser to output TAC instructions. Start by handling expressions and assignments: for each AST node (like binary op, assignment, etc.), output the corresponding sequence of IR instructions. Manage a simple symbol table of temporaries for intermediate results. By the end of the week, aim to handle basic arithmetic and maybe conditional branching in IR. _This assignment is typically due by next week (Week 10)_ ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=13%20at%20Midnight%20Problem%20Set,withdrawal%29%20grade)), so make steady progress now.

## Week 10: Code Generation (MIPS Assembly) & Register Allocation

**Goal:** Translate the intermediate code into target machine code (MIPS assembly). This week focuses on implementing a code generator and introduces register allocation strategies to optimize the generated code ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,continued)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=15%20Eleventh%20class%20meeting,Register%20Allocation%20%26%20Spilling)).  
**Milestone:** By Week 10’s end, you will have a basic **MIPS code generator** that can produce assembly for your language, and you will have completed **Problem Set 5 (IR generation)** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%208,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%208)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). You will also start **Problem Set 6 (MIPS Assembly Code Generator)**, with the foundation of emitting real instructions for your compiler’s output ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)).

- **Topics Covered:** **Code Generation Basics:** learn how to map IR instructions to MIPS assembly. The class covers using MIPS instructions for arithmetic operations, memory access (loads and stores), and control flow (jumps and branches) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,Present)). There’s a review of MIPS addressing modes and calling convention as needed. **Code Generation Examples:** walk through generating code for sample high-level constructs (e.g., computing an expression into registers, implementing an `if` by using branch instructions and labels) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,Present)). **Register Allocation (Intro):** as programs use more variables than available registers, learn about strategies to allocate registers to variables. Class 11 presents an algorithm using **graph coloring for register allocation** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=15%20Eleventh%20class%20meeting,Register%20Allocation%20%26%20Spilling)) – each variable is a node in a graph, edges represent conflicts (simultaneous live variables), and coloring the graph with k colors corresponds to assigning variables to k registers without conflict. This method helps optimize register usage and decide when to spill to memory.
- **Readings:** **Aho et al. Chapter 8** – This chapter deals with **Code Generation** and touches on register allocation ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,Present)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=15%20Eleventh%20class%20meeting,Register%20Allocation%20%26%20Spilling)). Read about the issues in code generation (instruction selection, temp management, evaluation order) and the basics of register allocation. Also review the course’s **MIPS Assembly** reference (if provided, e.g., “MIPS Assembly Language in PDF”) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,113)) and any sample code given (the website mentions sample programs on the class site, which could be simple C programs compiled to MIPS). For register allocation, you might also glance at **Chapter 9’s section on register allocation** (although Chapter 9 is mainly optimizations, it often includes register allocation in global optimization context).
- **Lab/Assignment:** **Complete Problem Set 5 – Intermediate Code Generator:** Finalize your IR generation from last week and test it on multiple inputs. Ensure your IR covers all necessary language constructs since you’ll use it as input for assembly generation. Submit PSet 5 by its deadline (approximately this week) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=8%20Tenth%20class%20meeting,Present)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%208,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%208)).  
    **Problem Set 6 – MIPS Assembly Code Generator** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)): Begin implementing the back-end that translates IR to actual MIPS assembly code. You can start with a simple approach: allocate a fixed number of registers (naively or using a basic algorithm) and translate each IR instruction to one or more MIPS instructions. Handle arithmetic operations (map to `add, sub, mul, div`), memory operations (load/store for variables, likely using the data from your symbol table for addresses), and control flow (labels and branches for jumps). By the end of the week, aim to have your compiler generate runnable MIPS assembly for simple programs. You will refine and optimize this in the next week, possibly adding a smarter register allocation using graph coloring as discussed in class.

## Week 11: Code Optimization I – Optimizing Transformations

**Goal:** Improve the quality of the generated code through optimization. This week covers classic code optimizations and data-flow analysis, while you finish the last programming assignment and start planning the final project ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)).  
**Milestone:** By the end of Week 11, you will have a fully functioning compiler that generates MIPS code (**Problem Set 6 completed**) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). You will also lay out a plan for your **Final Project**, which involves implementing one or more optimizations in your compiler ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)).

- **Topics Covered:** **Code Optimization (Analysis and Transformations):** learn various optimization techniques that compilers use to improve performance. Key optimizations discussed include **common subexpression elimination**, **copy propagation**, **dead code elimination**, **constant folding**, **strength reduction** (e.g., replacing expensive operations with cheaper ones), **loop optimizations** (unrolling loops, reordering instructions, loop-invariant code motion), and **function inlining** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Complete%20discussion%20of)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=using%20graph%20coloring,output%2C%20and)). The concept of **Basic Blocks** and **Control Flow Graphs** is introduced to group instructions for optimization ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)). **Data-Flow Analysis:** understand how to gather information needed for optimizations (like liveness analysis for registers, reaching definitions, etc.) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)). For example, **use-def chains** and **liveness analysis** help determine if a variable’s value is still needed, enabling dead code removal ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)). Register allocation is revisited in depth, including spilling heuristics when not enough registers are available ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%209)). (Class 12 covers a lot of these fundamentals, and Class 13 continues with dependency analysis and advanced topics next week.)
- **Readings:** **Aho et al. Chapter 9** – This chapter deals with **Code Optimization** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=27%20at%20Midnight%20Problem%20Set,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%209)). Focus on sections about optimization of basic blocks and loops, and global data-flow analysis (which provides the theoretical framework for optimizations like dead code elimination). If provided, go through the course’s **Optimization** slides or notes ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,113)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,113)). They may list the specific optimizations you’re expected to implement or understand for the final project. Also review any sample code showing before-and-after optimization to see the impact.
- **Lab/Assignment:** **Complete Problem Set 6 – MIPS Code Generator:** Finalize your code generator from last week. Incorporate register allocation improvements if you haven’t already (e.g., implement the graph coloring algorithm for register assignment as outlined in class) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=15%20Eleventh%20class%20meeting,Register%20Allocation%20%26%20Spilling)). Test your end-to-end compiler by compiling several example programs in your subset language and running them on a MIPS simulator to verify correct output. Submit PSet 6 by its due date (around this week) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Midnight%20Problem%20Set%206%20due)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=jump%20threading%2C%20instruction%20scheduling%2C%20tail,meeting%2C%20read%20Aho%2FLam%2FSethi%2FUllman%20chapter%209)). This marks the completion of the core compiler!  
    **Plan the Final Project (Optimization):** The final project involves adding an optimization pass to your compiler ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). Now that you’ve learned many optimization techniques, decide which ones to implement. Common choices are optimizing the IR or assembly for constant folding, dead code elimination, or register allocation improvements. Formulate a plan: which optimization(s) will you implement, and how will you integrate them into your compiler pipeline? If the project is team-based (not in this context, but just in case), coordinate with any partners. By end of Week 11, start coding a basic optimization – for example, implement constant folding on your IR as a warm-up.

## Week 12: Code Optimization II, Parallelism & Final Project Delivery

**Goal:** Explore advanced optimization topics (including considerations for parallelism) and complete the final project. This week you will finish implementing your chosen optimizations and prepare a presentation or report on your compiler project ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=6%20Fourteenth%20class%20meeting,presentation%20material%20must%20be%20submitted)).  
**Milestone:** By the end of Week 12, you will submit the **Final Project** – an optimized compiler with an accompanying documentation/presentation ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=12,Grades%20available%20online%2029%20Commencement)). You will also have a high-level understanding of modern compiler optimization challenges (advanced topics beyond the basics).

- **Topics Covered:** **Advanced Optimizations:** The final class meeting discusses topics like **parallelism-aware optimizations** and any remaining advanced topics. For instance, the difference between **assertions vs. assumptions** in code and how a compiler might use them, optimizing for **data locality** (cache optimization) and **parallel execution** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=6%20Fourteenth%20class%20meeting,presentation%20material%20must%20be%20submitted)). The concept of massively parallel architectures and how compilers optimize for them (e.g., loop transformations for vectorization, concurrency considerations) may be introduced. Also, any **open issues or questions** students have on their term projects are addressed in this last session ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=6%20Fourteenth%20class%20meeting,presentation%20material%20must%20be%20submitted)). This is a forward-looking discussion that might not be directly applied in your project but gives insight into where compiler design is headed (just as Chapters 10–12 of the textbook do).
- **Readings:** **Aho et al. Chapters 10–12** – These chapters cover topics like code generation for advanced machines, loop optimizations, and parallel compilers ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=6%20Fourteenth%20class%20meeting,12)). Given time constraints, you may _selectively read or skim_ these for concepts of interest (such as how compilers handle instruction-level parallelism or memory hierarchy). The goal is breadth over depth here. Focus on any sections mentioned in class. If slides/notes are provided for these topics (e.g., “Dependencies, Instruction Scheduling, Optimization, and Parallelism” PDF) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,113)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#schedule#:~:text=,113)), use those to guide your study.
- **Lab/Assignment:** **Final Project – Optimization Implementation** ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). Complete the development of your optimization pass(es) in the compiler. Test the optimized compiler on various programs, comparing outputs and performance with and without optimizations if possible. Ensure your code is well-documented.  
    **Project Presentation/Report:** Prepare a brief presentation or write-up about your compiler and the optimizations you implemented. In the real course, students present on the final class meeting ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=12,Grades%20available%20online%2029%20Commencement)), so you should be able to explain the problem your optimization addresses, your approach, and demonstrate the improvement. Even in self-study, summarizing your work solidifies your understanding.  
    **Submit Final Project**: Package your final code, documentation, and presentation slides (if any) and submit by the end of the week ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=12,Grades%20available%20online%2029%20Commencement)). This submission marks the completion of the course. Congratulations – you have built a compiler!

---

**Conclusion:** Over these 3 months, you progressed through all phases of compiler construction: lexical analysis, parsing, semantic analysis (symbol table & type checking), intermediate code generation, machine code generation, and optimization. Each week’s structured goals and milestones ensured steady progress. By following this full-time schedule and completing all readings and labs, you have effectively covered the content of CSCI E-95 Spring 2025 ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#:~:text=Compiler%20Design%20and%20Implementation%20)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=27%20Classes%20begin%20,of%20the%20C%20Programming%20Language)). You should now have a deep practical and theoretical understanding of compiler design and a functioning compiler to show for it. Good luck with applying these skills to future projects or courses!

**Sources:** The schedule and content are based on the official CSCI E-95 Spring 2025 course website ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=28%20at%208%3A00%20PM%20ET,of%20the%20C%20Programming%20Language)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=22%20Twelfth%20class%20meeting,Complete%20discussion%20of)), including lecture topics, textbook readings, and assignments. All problem set titles and due sequences are drawn from the course material ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,122)) ([Course Website for CSCI E-95 Spring 2025](https://cscie95.dce.harvard.edu/spring2025/index.html#outline#:~:text=,Final%20Project%20%28Optimization)). This plan organizes that content into a cohesive full-time learning path. Enjoy your compiler-building journey!